<?php
 namespace Avifinfo; const FOUND = 0; const NOT_FOUND = 1; const TRUNCATED = 2; const ABORTED = 3; const INVALID = 4; const MAX_SIZE = 4294967295; const MAX_NUM_BOXES = 4096; const MAX_VALUE = 255; const MAX_TILES = 16; const MAX_PROPS = 32; const MAX_FEATURES = 8; const UNDEFINED = 0; function read_big_endian( $input, $num_bytes ) { if ( $num_bytes == 1 ) { return unpack( 'C', $input ) [1]; } else if ( $num_bytes == 2 ) { return unpack( 'n', $input ) [1]; } else if ( $num_bytes == 3 ) { $bytes = unpack( 'C3', $input ); return ( $bytes[1] << 16 ) | ( $bytes[2] << 8 ) | $bytes[3]; } else { return unpack( 'N', $input ) [1]; } } function read( $handle, $num_bytes ) { $data = fread( $handle, $num_bytes ); return ( $data !== false && strlen( $data ) >= $num_bytes ) ? $data : false; } function skip( $handle, $num_bytes ) { return ( fseek( $handle, $num_bytes, SEEK_CUR ) == 0 ); } class Tile { public $tile_item_id; public $parent_item_id; } class Prop { public $property_index; public $item_id; } class Dim_Prop { public $property_index; public $width; public $height; } class Chan_Prop { public $property_index; public $bit_depth; public $num_channels; } class Features { public $has_primary_item = false; public $has_alpha = false; public $primary_item_id; public $primary_item_features = array( 'width' => UNDEFINED, 'height' => UNDEFINED, 'bit_depth' => UNDEFINED, 'num_channels' => UNDEFINED ); public $tiles = array(); public $props = array(); public $dim_props = array(); public $chan_props = array(); private function get_item_features( $target_item_id, $tile_depth ) { foreach ( $this->props as $prop ) { if ( $prop->item_id != $target_item_id ) { continue; } if ( $target_item_id == $this->primary_item_id && ( $this->primary_item_features['width'] == UNDEFINED || $this->primary_item_features['height'] == UNDEFINED ) ) { foreach ( $this->dim_props as $dim_prop ) { if ( $dim_prop->property_index != $prop->property_index ) { continue; } $this->primary_item_features['width'] = $dim_prop->width; $this->primary_item_features['height'] = $dim_prop->height; if ( $this->primary_item_features['bit_depth'] != UNDEFINED && $this->primary_item_features['num_channels'] != UNDEFINED ) { return FOUND; } break; } } if ( $this->primary_item_features['bit_depth'] == UNDEFINED || $this->primary_item_features['num_channels'] == UNDEFINED ) { foreach ( $this->chan_props as $chan_prop ) { if ( $chan_prop->property_index != $prop->property_index ) { continue; } $this->primary_item_features['bit_depth'] = $chan_prop->bit_depth; $this->primary_item_features['num_channels'] = $chan_prop->num_channels; if ( $this->primary_item_features['width'] != UNDEFINED && $this->primary_item_features['height'] != UNDEFINED ) { return FOUND; } break; } } } if ( $tile_depth < 3 ) { foreach ( $this->tiles as $tile ) { if ( $tile->parent_item_id != $target_item_id ) { continue; } $status = get_item_features( $tile->tile_item_id, $tile_depth + 1 ); if ( $status != NOT_FOUND ) { return $status; } } } return NOT_FOUND; } public function get_primary_item_features() { if ( !$this->has_primary_item ) { return NOT_FOUND; } if ( empty( $this->dim_props ) || empty( $this->chan_props ) ) { return NOT_FOUND; } $status = $this->get_item_features( $this->primary_item_id, 0 ); if ( $status != FOUND ) { return $status; } if ( $this->has_alpha ) { ++$this->primary_item_features['num_channels']; } return FOUND; } } class Box { public $size; public $type; public $version; public $flags; public $content_size; public function parse( $handle, &$num_parsed_boxes, $num_remaining_bytes = MAX_SIZE ) { $header_size = 8; if ( $header_size > $num_remaining_bytes ) { return INVALID; } if ( !( $data = read( $handle, 8 ) ) ) { return TRUNCATED; } $this->size = read_big_endian( $data, 4 ); $this->type = substr( $data, 4, 4 ); if ( $this->size == 1 ) { $header_size += 8; if ( $header_size > $num_remaining_bytes ) { return INVALID; } if ( !( $data = read( $handle, 8 ) ) ) { return TRUNCATED; } if ( read_big_endian( $data, 4 ) != 0 ) { return ABORTED; } $this->size = read_big_endian( substr( $data, 4, 4 ), 4 ); } else if ( $this->size == 0 ) { $this->size = $num_remaining_bytes; } if ( $this->size < $header_size ) { return INVALID; } if ( $this->size > $num_remaining_bytes ) { return INVALID; } $has_fullbox_header = $this->type == 'meta' || $this->type == 'pitm' || $this->type == 'ipma' || $this->type == 'ispe' || $this->type == 'pixi' || $this->type == 'iref' || $this->type == 'auxC'; if ( $has_fullbox_header ) { $header_size += 4; } if ( $this->size < $header_size ) { return INVALID; } $this->content_size = $this->size - $header_size; ++$num_parsed_boxes; if ( $num_parsed_boxes >= MAX_NUM_BOXES ) { return ABORTED; } $this->version = 0; $this->flags = 0; if ( $has_fullbox_header ) { if ( !( $data = read( $handle, 4 ) ) ) { return TRUNCATED; } $this->version = read_big_endian( $data, 1 ); $this->flags = read_big_endian( substr( $data, 1, 3 ), 3 ); $is_parsable = ( $this->type == 'meta' && $this->version <= 0 ) || ( $this->type == 'pitm' && $this->version <= 1 ) || ( $this->type == 'ipma' && $this->version <= 1 ) || ( $this->type == 'ispe' && $this->version <= 0 ) || ( $this->type == 'pixi' && $this->version <= 0 ) || ( $this->type == 'iref' && $this->version <= 1 ) || ( $this->type == 'auxC' && $this->version <= 0 ); if ( !$is_parsable ) { $this->type = 'unknownversion'; } } return FOUND; } } class Parser { private $handle; private $num_parsed_boxes = 0; private $data_was_skipped = false; public $features; function __construct( $handle ) { $this->handle = $handle; $this->features = new Features(); } private function parse_ipco( $num_remaining_bytes ) { $box_index = 1; do { $box = new Box(); $status = $box->parse( $this->handle, $this->num_parsed_boxes, $num_remaining_bytes ); if ( $status != FOUND ) { return $status; } if ( $box->type == 'ispe' ) { if ( $box->content_size < 8 ) { return INVALID; } if ( !( $data = read( $this->handle, 8 ) ) ) { return TRUNCATED; } $width = read_big_endian( substr( $data, 0, 4 ), 4 ); $height = read_big_endian( substr( $data, 4, 4 ), 4 ); if ( $width == 0 || $height == 0 ) { return INVALID; } if ( count( $this->features->dim_props ) <= MAX_FEATURES && $box_index <= MAX_VALUE ) { $dim_prop_count = count( $this->features->dim_props ); $this->features->dim_props[$dim_prop_count] = new Dim_Prop(); $this->features->dim_props[$dim_prop_count]->property_index = $box_index; $this->features->dim_props[$dim_prop_count]->width = $width; $this->features->dim_props[$dim_prop_count]->height = $height; } else { $this->data_was_skipped = true; } if ( !skip( $this->handle, $box->content_size - 8 ) ) { return TRUNCATED; } } else if ( $box->type == 'pixi' ) { if ( $box->content_size < 1 ) { return INVALID; } if ( !( $data = read( $this->handle, 1 ) ) ) { return TRUNCATED; } $num_channels = read_big_endian( $data, 1 ); if ( $num_channels < 1 ) { return INVALID; } if ( $box->content_size < 1 + $num_channels ) { return INVALID; } if ( !( $data = read( $this->handle, 1 ) ) ) { return TRUNCATED; } $bit_depth = read_big_endian( $data, 1 ); if ( $bit_depth < 1 ) { return INVALID; } for ( $i = 1; $i < $num_channels; ++$i ) { if ( !( $data = read( $this->handle, 1 ) ) ) { return TRUNCATED; } if ( read_big_endian( $data, 1 ) != $bit_depth ) { return INVALID; } if ( $i > 32 ) { return ABORTED; } } if ( count( $this->features->chan_props ) <= MAX_FEATURES && $box_index <= MAX_VALUE && $bit_depth <= MAX_VALUE && $num_channels <= MAX_VALUE ) { $chan_prop_count = count( $this->features->chan_props ); $this->features->chan_props[$chan_prop_count] = new Chan_Prop(); $this->features->chan_props[$chan_prop_count]->property_index = $box_index; $this->features->chan_props[$chan_prop_count]->bit_depth = $bit_depth; $this->features->chan_props[$chan_prop_count]->num_channels = $num_channels; } else { $this->data_was_skipped = true; } if ( !skip( $this->handle, $box->content_size - ( 1 + $num_channels ) ) ) { return TRUNCATED; } } else if ( $box->type == 'av1C' ) { if ( $box->content_size < 3 ) { return INVALID; } if ( !( $data = read( $this->handle, 3 ) ) ) { return TRUNCATED; } $byte = read_big_endian( substr( $data, 2, 1 ), 1 ); $high_bitdepth = ( $byte & 0x40 ) != 0; $twelve_bit = ( $byte & 0x20 ) != 0; $monochrome = ( $byte & 0x10 ) != 0; if ( $twelve_bit && !$high_bitdepth ) { return INVALID; } if ( count( $this->features->chan_props ) <= MAX_FEATURES && $box_index <= MAX_VALUE ) { $chan_prop_count = count( $this->features->chan_props ); $this->features->chan_props[$chan_prop_count] = new Chan_Prop(); $this->features->chan_props[$chan_prop_count]->property_index = $box_index; $this->features->chan_props[$chan_prop_count]->bit_depth = $high_bitdepth ? $twelve_bit ? 12 : 10 : 8; $this->features->chan_props[$chan_prop_count]->num_channels = $monochrome ? 1 : 3; } else { $this->data_was_skipped = true; } if ( !skip( $this->handle, $box->content_size - 3 ) ) { return TRUNCATED; } } else if ( $box->type == 'auxC' ) { $kAlphaStr = "urn:mpeg:mpegB:cicp:systems:auxiliary:alpha\0"; $kAlphaStrLength = 44; if ( $box->content_size >= $kAlphaStrLength ) { if ( !( $data = read( $this->handle, $kAlphaStrLength ) ) ) { return TRUNCATED; } if ( substr( $data, 0, $kAlphaStrLength ) == $kAlphaStr ) { $this->features->has_alpha = true; } if ( !skip( $this->handle, $box->content_size - $kAlphaStrLength ) ) { return TRUNCATED; } } else { if ( !skip( $this->handle, $box->content_size ) ) { return TRUNCATED; } } } else { if ( !skip( $this->handle, $box->content_size ) ) { return TRUNCATED; } } ++$box_index; $num_remaining_bytes -= $box->size; } while ( $num_remaining_bytes > 0 ); return NOT_FOUND; } private function parse_iprp( $num_remaining_bytes ) { do { $box = new Box(); $status = $box->parse( $this->handle, $this->num_parsed_boxes, $num_remaining_bytes ); if ( $status != FOUND ) { return $status; } if ( $box->type == 'ipco' ) { $status = $this->parse_ipco( $box->content_size ); if ( $status != NOT_FOUND ) { return $status; } } else if ( $box->type == 'ipma' ) { $num_read_bytes = 4; if ( $box->content_size < $num_read_bytes ) { return INVALID; } if ( !( $data = read( $this->handle, $num_read_bytes ) ) ) { return TRUNCATED; } $entry_count = read_big_endian( $data, 4 ); $id_num_bytes = ( $box->version < 1 ) ? 2 : 4; $index_num_bytes = ( $box->flags & 1 ) ? 2 : 1; $essential_bit_mask = ( $box->flags & 1 ) ? 0x8000 : 0x80; for ( $entry = 0; $entry < $entry_count; ++$entry ) { if ( $entry >= MAX_PROPS || count( $this->features->props ) >= MAX_PROPS ) { $this->data_was_skipped = true; break; } $num_read_bytes += $id_num_bytes + 1; if ( $box->content_size < $num_read_bytes ) { return INVALID; } if ( !( $data = read( $this->handle, $id_num_bytes + 1 ) ) ) { return TRUNCATED; } $item_id = read_big_endian( substr( $data, 0, $id_num_bytes ), $id_num_bytes ); $association_count = read_big_endian( substr( $data, $id_num_bytes, 1 ), 1 ); for ( $property = 0; $property < $association_count; ++$property ) { if ( $property >= MAX_PROPS || count( $this->features->props ) >= MAX_PROPS ) { $this->data_was_skipped = true; break; } $num_read_bytes += $index_num_bytes; if ( $box->content_size < $num_read_bytes ) { return INVALID; } if ( !( $data = read( $this->handle, $index_num_bytes ) ) ) { return TRUNCATED; } $value = read_big_endian( $data, $index_num_bytes ); $property_index = ( $value & ~$essential_bit_mask ); if ( $property_index <= MAX_VALUE && $item_id <= MAX_VALUE ) { $prop_count = count( $this->features->props ); $this->features->props[$prop_count] = new Prop(); $this->features->props[$prop_count]->property_index = $property_index; $this->features->props[$prop_count]->item_id = $item_id; } else { $this->data_was_skipped = true; } } if ( $property < $association_count ) { break; } } $status = $this->features->get_primary_item_features(); if ( $status != NOT_FOUND ) { return $status; } if ( !skip( $this->handle, $box->content_size - $num_read_bytes ) ) { return TRUNCATED; } } else { if ( !skip( $this->handle, $box->content_size ) ) { return TRUNCATED; } } $num_remaining_bytes -= $box->size; } while ( $num_remaining_bytes > 0 ); return NOT_FOUND; } private function parse_iref( $num_remaining_bytes ) { do { $box = new Box(); $status = $box->parse( $this->handle, $this->num_parsed_boxes, $num_remaining_bytes ); if ( $status != FOUND ) { return $status; } if ( $box->type == 'dimg' ) { $num_bytes_per_id = ( $box->version == 0 ) ? 2 : 4; $num_read_bytes = $num_bytes_per_id + 2; if ( $box->content_size < $num_read_bytes ) { return INVALID; } if ( !( $data = read( $this->handle, $num_read_bytes ) ) ) { return TRUNCATED; } $from_item_id = read_big_endian( $data, $num_bytes_per_id ); $reference_count = read_big_endian( substr( $data, $num_bytes_per_id, 2 ), 2 ); for ( $i = 0; $i < $reference_count; ++$i ) { if ( $i >= MAX_TILES ) { $this->data_was_skipped = true; break; } $num_read_bytes += $num_bytes_per_id; if ( $box->content_size < $num_read_bytes ) { return INVALID; } if ( !( $data = read( $this->handle, $num_bytes_per_id ) ) ) { return TRUNCATED; } $to_item_id = read_big_endian( $data, $num_bytes_per_id ); $tile_count = count( $this->features->tiles ); if ( $from_item_id <= MAX_VALUE && $to_item_id <= MAX_VALUE && $tile_count < MAX_TILES ) { $this->features->tiles[$tile_count] = new Tile(); $this->features->tiles[$tile_count]->tile_item_id = $to_item_id; $this->features->tiles[$tile_count]->parent_item_id = $from_item_id; } else { $this->data_was_skipped = true; } } $status = $this->features->get_primary_item_features(); if ( $status != NOT_FOUND ) { return $status; } if ( !skip( $this->handle, $box->content_size - $num_read_bytes ) ) { return TRUNCATED; } } else { if ( !skip( $this->handle, $box->content_size ) ) { return TRUNCATED; } } $num_remaining_bytes -= $box->size; } while ( $num_remaining_bytes > 0 ); return NOT_FOUND; } private function parse_meta( $num_remaining_bytes ) { do { $box = new Box(); $status = $box->parse( $this->handle, $this->num_parsed_boxes, $num_remaining_bytes ); if ( $status != FOUND ) { return $status; } if ( $box->type == 'pitm' ) { $num_bytes_per_id = ( $box->version == 0 ) ? 2 : 4; if ( $num_bytes_per_id > $num_remaining_bytes ) { return INVALID; } if ( !( $data = read( $this->handle, $num_bytes_per_id ) ) ) { return TRUNCATED; } $primary_item_id = read_big_endian( $data, $num_bytes_per_id ); if ( $primary_item_id > MAX_VALUE ) { return ABORTED; } $this->features->has_primary_item = true; $this->features->primary_item_id = $primary_item_id; if ( !skip( $this->handle, $box->content_size - $num_bytes_per_id ) ) { return TRUNCATED; } } else if ( $box->type == 'iprp' ) { $status = $this->parse_iprp( $box->content_size ); if ( $status != NOT_FOUND ) { return $status; } } else if ( $box->type == 'iref' ) { $status = $this->parse_iref( $box->content_size ); if ( $status != NOT_FOUND ) { return $status; } } else { if ( !skip( $this->handle, $box->content_size ) ) { return TRUNCATED; } } $num_remaining_bytes -= $box->size; } while ( $num_remaining_bytes != 0 ); return INVALID; } public function parse_ftyp() { $box = new Box(); $status = $box->parse( $this->handle, $this->num_parsed_boxes ); if ( $status != FOUND ) { return false; } if ( $box->type != 'ftyp' ) { return false; } if ( $box->content_size < 8 ) { return false; } for ( $i = 0; $i + 4 <= $box->content_size; $i += 4 ) { if ( !( $data = read( $this->handle, 4 ) ) ) { return false; } if ( $i == 4 ) { continue; } if ( substr( $data, 0, 4 ) == 'avif' || substr( $data, 0, 4 ) == 'avis' ) { return skip( $this->handle, $box->content_size - ( $i + 4 ) ); } if ( $i > 32 * 4 ) { return false; } } return false; } public function parse_file() { $box = new Box(); while ( $box->parse( $this->handle, $this->num_parsed_boxes ) == FOUND ) { if ( $box->type === 'meta' ) { if ( $this->parse_meta( $box->content_size ) != FOUND ) { return false; } return true; } if ( !skip( $this->handle, $box->content_size ) ) { return false; } } return false; } } 