<?php
 if (class_exists('ParagonIE_Sodium_Core_SipHash', false)) { return; } class ParagonIE_Sodium_Core_SipHash extends ParagonIE_Sodium_Core_Util { public static function sipRound(array $v) { list($v[0], $v[1]) = self::add( array($v[0], $v[1]), array($v[2], $v[3]) ); list($v[2], $v[3]) = self::rotl_64((int) $v[2], (int) $v[3], 13); $v[2] = (int) $v[2] ^ (int) $v[0]; $v[3] = (int) $v[3] ^ (int) $v[1]; list($v[0], $v[1]) = self::rotl_64((int) $v[0], (int) $v[1], 32); list($v[4], $v[5]) = self::add( array((int) $v[4], (int) $v[5]), array((int) $v[6], (int) $v[7]) ); list($v[6], $v[7]) = self::rotl_64((int) $v[6], (int) $v[7], 16); $v[6] = (int) $v[6] ^ (int) $v[4]; $v[7] = (int) $v[7] ^ (int) $v[5]; list($v[0], $v[1]) = self::add( array((int) $v[0], (int) $v[1]), array((int) $v[6], (int) $v[7]) ); list($v[6], $v[7]) = self::rotl_64((int) $v[6], (int) $v[7], 21); $v[6] = (int) $v[6] ^ (int) $v[0]; $v[7] = (int) $v[7] ^ (int) $v[1]; list($v[4], $v[5]) = self::add( array((int) $v[4], (int) $v[5]), array((int) $v[2], (int) $v[3]) ); list($v[2], $v[3]) = self::rotl_64((int) $v[2], (int) $v[3], 17); $v[2] = (int) $v[2] ^ (int) $v[4]; $v[3] = (int) $v[3] ^ (int) $v[5]; list($v[4], $v[5]) = self::rotl_64((int) $v[4], (int) $v[5], 32); return $v; } public static function add(array $a, array $b) { $x1 = $a[1] + $b[1]; $c = $x1 >> 32; $x0 = $a[0] + $b[0] + $c; return array( $x0 & 0xffffffff, $x1 & 0xffffffff ); } public static function rotl_64($int0, $int1, $c) { $int0 &= 0xffffffff; $int1 &= 0xffffffff; $c &= 63; if ($c === 32) { return array($int1, $int0); } if ($c > 31) { $tmp = $int1; $int1 = $int0; $int0 = $tmp; $c &= 31; } if ($c === 0) { return array($int0, $int1); } return array( 0xffffffff & ( ($int0 << $c) | ($int1 >> (32 - $c)) ), 0xffffffff & ( ($int1 << $c) | ($int0 >> (32 - $c)) ), ); } public static function sipHash24($in, $key) { $inlen = self::strlen($in); $v = array( 0x736f6d65, 0x70736575, 0x646f7261, 0x6e646f6d, 0x6c796765, 0x6e657261, 0x74656462, 0x79746573 ); $k = array( self::load_4(self::substr($key, 4, 4)), self::load_4(self::substr($key, 0, 4)), self::load_4(self::substr($key, 12, 4)), self::load_4(self::substr($key, 8, 4)) ); $b = array( $inlen << 24, 0 ); $v[6] ^= $k[2]; $v[7] ^= $k[3]; $v[4] ^= $k[0]; $v[5] ^= $k[1]; $v[2] ^= $k[2]; $v[3] ^= $k[3]; $v[0] ^= $k[0]; $v[1] ^= $k[1]; $left = $inlen; while ($left >= 8) { $m = array( self::load_4(self::substr($in, 4, 4)), self::load_4(self::substr($in, 0, 4)) ); $v[6] ^= $m[0]; $v[7] ^= $m[1]; $v = self::sipRound($v); $v = self::sipRound($v); $v[0] ^= $m[0]; $v[1] ^= $m[1]; $in = self::substr($in, 8); $left -= 8; } switch ($left) { case 7: $b[0] |= self::chrToInt($in[6]) << 16; case 6: $b[0] |= self::chrToInt($in[5]) << 8; case 5: $b[0] |= self::chrToInt($in[4]); case 4: $b[1] |= self::chrToInt($in[3]) << 24; case 3: $b[1] |= self::chrToInt($in[2]) << 16; case 2: $b[1] |= self::chrToInt($in[1]) << 8; case 1: $b[1] |= self::chrToInt($in[0]); case 0: break; } $v[6] ^= $b[0]; $v[7] ^= $b[1]; $v = self::sipRound($v); $v = self::sipRound($v); $v[0] ^= $b[0]; $v[1] ^= $b[1]; $v[5] ^= 0xff; $v = self::sipRound($v); $v = self::sipRound($v); $v = self::sipRound($v); $v = self::sipRound($v); return self::store32_le($v[1] ^ $v[3] ^ $v[5] ^ $v[7]) . self::store32_le($v[0] ^ $v[2] ^ $v[4] ^ $v[6]); } } 